# 机试(Java)

## 一、从零开始

## 二、暴力求解

### 2.1 枚举

#### 例题1(类水仙花数)：

- 枚举是指对每个可能的解进行逐一判断，直到找到符合题目要求的答案。
- 枚举类的题目本身并不复杂,但在采取枚举策略之前，一定要好好分析题目的枚举量,枚举量过大时，
- 需要选择其他解决方法。即使问题适合用枚举策略来求解，也最好对题目进行一定的分析,以便通过减少部分无效的枚举来使得程序更加简洁和高效

```java
/*
    例题1 abc (清华大学复试上机题)
    -题目描述:
    设a,b,c均是0到9之间的数字，abc, bcc是两个三位数，且有abc + bcc = 532。
    求满足条件的所有a,b,c的值。
    -输入:
    题目没有任何输入.
    -输出:
    1.请输出所有满足题目条件的a,b,c的值。
    2.a,b,c之间用空格隔开。
    3.每个输出占一行。
*/
public class EnumDemo {
    public static void main(String[] args) {
        int a, b, c;
        for (a = 0; a <= 9; a++)
            for (b = 0; b <= 9; b++)
                for (c = 0; c <= 9; c++) {
                    int abc = 100 * a + 10 * b + c;
                    int bcc = 100 * b + 11 * c;
                    if (abc + bcc == 532) {
                        System.out.println(a);
                        System.out.println(b);
                        System.out.println(c);
                    }
                }
    }
}
```

分析：

​	本题只有a,b,c三个从0到9的数,枚举量仅为10x10x10= 1000,所以本题可让a, b,c从0枚举到9，每当遇到符合题目要求的解，就输出它。但在动手写代码之前，可以再做一些分析: 
abc= 100a+ 10b+C, bcc= 100b+ 11c,于是abc+ bcc= 100a+ 110b+ 12c.
因此，只需判断前一个等式的右侧是否等于532即可，这样便简化了加法。

#### 例题2(反序数)：

题目描述:
	设N是一个4位数，它的9倍恰好是其反序数(如1234的反序数是4321),求N的值。
输入:题目没有任何输入。
输出:输出题目要求的4位数，如果结果有多组，那么每组结果之间以回车隔开。

```java
/*
题目描述:
	设N是一个4位数，它的9倍恰好是其反序数(如1234的反序数是4321),求N的值。
输入:题目没有任何输入。
输出:输出题目要求的4位数，如果结果有多组，那么每组结果之间以回车隔开。
*/
public class ReverseNum {
    int reverse(int x) {
        int rev = 0;
        while (x != 0) { //反序操作
            rev *= 10; //上位操作,第一遍为0，例原来为个位-》十位
            rev += x % 10; //通过取余操作,取其个位数
            x /= 10; //x向下降一位,例原来为千位-》百位
          //直到x为0
        }
        return rev;
    }
    public static void main(String[] args) {
        //枚举1000-9999的反序数
        ReverseNum rn = new ReverseNum();
        for (int i = 1000; i < 10000; i++) {
            if (i * 9 == rn.reverse(i))
                System.out.println(i);
        }
    }
}

```

分析：

题目中所求的N为4位数,因此N的取值范围只可能是1000~9999,枚举量不到10000,
对于每个数，只需要求它的反序数即可。要求一个数的反序数，只需进行该数的位数次运
算便可得到;例如对于数1234，只需进行4次运算便可得到4321.于是，本题枚举所有N
的运算次数不超过4x 10000 = 40000，所以本题可以采用枚举法来求解。

#### 例题3(反序变形 => 对称平方数1)：



```java
题目描述:
		打印所有不超过256,其平方具有对称性质的数。如2和11就是这样的数,因为2x2 =4,11x11= 121。
    输入:
    	题目没有任何输入。
    输出:
    	输出具有题目要求的性质的数。如果输出数据不止一组，那么各组数据之间以回车隔开。
分析：
		- 只需要比较一个数的反序数和这个数本身的值是否相等来判断数字是否具有对称性质。
		- 通过上题可知，要求一个数的反序数，只需进行该数位数的运算次数就可得到。
		- 这道题只需从0的平方枚举到256的平方便可以得到答案，其中枚举到的最大数是256x256 =
  	- 65536，而最大数65536也只需要5次运算便可以得到它的反序数。于是，运算次数必定
  	- 小于257x5= 1285，所以本题可以通过枚举法求解。
        
public class Symmetrical {
  public int reverse(int x) {
    int rev = 0;
    while (x != 0) {
      rev *= 10;
      rev += x % 10;
      x /= 10;
    }
    return rev;
  }
  public static void main(String[] args) {
    Symmetrical st = new Symmetrical();
    for (int i = 0; i <= 256; i++){
      if (i*i == st.reverse(i*i))
        System.out.println(i);
    }
  }
}
```

#### 习题 1(与7无关的数字)

```java
/*
    一个正整数，如果它能被7整除，或者它的十进制表示法中某个位数上的数字为7,那么称其为与7相关的数。
    现求所有小于等于n (n< 100)的与7无关的正整数的平方和
*/
public class WithoutSeven {
  public static void main(String[] args) {
    for (int i = 0; i < 100; i++) {
      //被7整除 or 个位数为7
      if (i % 7 == 0 || i % 10 == 7){
					//符合7相关数字,不打印
      }else
        System.out.println(i);
    }
  }
}
```

#### 习题 2(百鸡问题)

```java
/*
    用小于等于100元去买100只鸡，大鸡5元/只，小鸡3元/只，还有1/3元每只的一种小鸡，分别
    记为x只、y只和z只。编程求解x, y, z所有可能的解。
*/
public class HundredChicken {
  public static void main(String[] args) {
    int x,y,z;
    //公鸡最大上限20，所以之前100是错的
    for(x = 0 ; x <= 20 ; x++) {
      //母鸡最大上限33
      for(y = 0; y <= 33; y++) {
        z = 100 - x - y ;
        //小鸡要同时满足整除
        if(x*5+y*3+z/3==100  && z %3 == 0) {
          System.out.println("公鸡："+x+"只"+"\t"+"母鸡： "+y+"只"+"\t"+"小鸡"+z+"只");
        }
      }
    }

  }
}

```

#### 习题 3 (上海交大 => Old Bill)=>难

```java
/*
    N只火鸡的价格为$_XYZ_，火鸡的总数N在1到99之间。
    价格由五位数组成，两边的数字由于褪色而看不清，所以只能看到中间的三位数。
    假设第一个数字非零，每只火鸡的价格是整数，并且所有火鸡的价格相同。
    给定N,X, Y和Z,编写一个程序来猜测两边褪色的数字和火鸡的原始价格。如果有多个价格符合题意，那么输出最昂贵的那个
*/
//注： 本题使用枚举法解题，因为题干中要求输出最大单价，所以直接采取了从大到小的遍历方式（最大值9999也可更改为90009 + num）
public class OldBill {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        while (input.hasNext()) {
            int N = input.nextInt();
            int x = input.nextInt();
            int y = input.nextInt();
            int z = input.nextInt();
            handle(N, x, y, z);
        }
        input.close();
    }

    public static void handle(int N, int x, int y, int z) {
        int num = 1000 * x + 100 * y + 10 * z; //中间三位数xyz0
        int multiply = 99999; //初始总价  = 最大价格
        int money = 99999 / N; //一只火鸡初始单价
        //xyz是固定的,所以最小的5位数是 => 1xyz0
        while (multiply >= (10000 + num)) {
            multiply = N * money; //总价 = 单价*数量
            //若 xyz(千位=>百位) == 总价/10(千位)%1000 => 百位
            if ((num / 10) == (multiply / 10) % 1000) {
                System.out.print((multiply / 10000) % 10 + " "); //求万位数字
                System.out.print(multiply % 10 + " "); //求个位数字
                System.out.println(money);
                return;
            }
            money--;
        }
        System.out.println(0);
    }
}
```

### 2.2 模拟

​		模拟类题目是机试题中出现**频率很高**的一种类型，这类题目的特点是并不涉及特别高深的知识，只需利用程序实现题目的要求。由于这类题目通常不需要经过太多的思考,所以能够很纯粹地考查考生的编程能力。

#### 2.2.1 图形排版

​		图形排版是最为常见的模拟类题型，这类题目要求考生按照特定规则输出字符，主要
考查考生对输出格式的把握。通常来说这类题目的规律性比较强，掌握了题目中的规律，
题目便能迎刃而解。

##### 例题1(输出梯形)

```java
/**
 * 输入一个高度h,输出一个高度为h、上底边长度为h的梯形。
 * 一个整数h (1 ≤h≤1000),每层相差两个单位的 *
 * 实现的效果：
 * System.out.println("      ****");
 * System.out.println("    ******");
 * System.out.println("  ********");
 * System.out.println("**********");
 */

这道题是考查输出格式的典型真题。观察输出图形可发现其具有较强的规律性:
①梯形的高度是h,故图形的行数为h。
②首行有h个“*”，下一行中总是比上一行中多两个“*”，故第i行有h+2*i个“*"。
③最后一行中“*”的数量决定了图像的列数。
④每行都右对齐，左边空余的位置输出空格，空格数是列数与该行中“*”的数量之差。

public static void main(String[] args) {
        //输入流
        Scanner input = new Scanner(System.in);
        int h = input.nextInt();

        int row = h; //行高为h
        int col = h + (h - 1) * 2; //列的宽度为(2、4、6、8、10，An = A1+(n-1)*d 公差d=2)
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (j < col - (h + i * 2))
                    //假设第一行不输出*，那么就有col宽度的 " "，设定初始有h个 * ，所以输出col-h个空格
                    //每行依次递增两颗 * ，相应的依次少输出两个" "，因此公式为上
                    System.out.print(" ");
                else
                    //空格输出完再输出*
                    System.out.print("*");
            }
            System.out.println();
        }
}
```

##### 例题2(叠筐)=>难、未做

```java
/*
    叠筐
    把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算
机来完成，得看你的了。
    输入:
        输入是一个个三元组，分别是:外筐尺寸n (n为满足0<n<80的奇整数)，
        中心花色字符，外筐花色字符，后二者都为ASCII可见字符。
    输出:
        输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外管的角总是被打磨掉。
        叠筐与叠筐之间应有一行间隔。
    分析：
        如本题的样例输出所示，输出图形的规律性主要体现在由外而内的各个圈上，
        而这与输出顺序又不太契合(从上至下，从左至右)，不容易将该图形存在的规律直接应用到输出中，
        所以需要使用刚才提到的办法，即先构造后输出。利用观察到的“圈形规律”构造图形，
        构造完成后再按照先行后列的方式输出图形。构造的理念如下:
        ①先将4个角补上，成为一个正方形。.
        ②从外圈向内圈逐步构造。
        ③用圈的左上角和右下角坐标来表示圈。
        ④决定圈的填充字符是中心字符还是外筐字符。
        ⑤确定圈填充字符的边长。
        ⑥构造完成后再将4个角剔除。
*/

public class FoldBasket {
    public static void main(String[] args) {

    }
}

```

如上面的代码所示，并不是在输出时使用得到的规律，而用另一种更容易的方法完成排版。
利用一个缓存数组来表示将要输出的字符阵列，对该字符阵列的坐标做如下规定:
		规定阵列左上角字符的坐标为(0, 0),阵列右下角字符的坐标为(n-1 ,n-1),其他坐标可由此推得。
		程序按照由最外圈至最内圈的顺序来完成图形的排列。
		完成每圈排列时，需要注意以下几个要点:
			①需要确定该圈左上角和右下角的坐标，将以这两个坐标为参照点来完成该圈的其他字符位置的确定(也可选用其			他点)。观察图形得知，从最外圈的左上角(0,0)到最中间圈的左上角(n/2,n/2)都是(i,i)的格式，从最外圈的右下角(n-			1,n-1)到最中间圈的右下角(n/2,n/2)都是(j,j)的格式，所以i和j的关系为i+j=n-1.
			②需要确定该圈使用哪个字符来填充，这由该圈是从内向外数的第几个圈来决定的。
			如果是奇数圈，那么用中心花色字符填充;如果是偶数圈，那么用外筐花色字符填充。
			对于左上角为(i, i)的圈来说，可以通过(n/2-i)的奇偶性来判断。
			③需要计算该圈填充字符的边长。这也很容易得出:最外圈为n,次外圈为n-2，外圈总比内圈长度多2。于是，对左			上角为(i, i)的圈来说，长度为n-2*i
		另外，上述代码中还有以下两个值得注意的地方:
			①输出格式。题面要求在输出的每个叠筐间输出一一个空行，即除最后一个叠筐输出后没有额外的空行外，其他叠			筐输出后都需要额外输出一个空行。为了完成这一要求，可以将要求形式改变为:除在第一个输出的叠筐前，不输			出一个空行外，在其他每个输出的叠筐前都需要输出一个额外的空行。两种要求形式是等价的。为完成这一目的，			在程序开头声明了变量firstCase来表示正在处理的数据是否为第一组数据，它的初始值为true. 程序读取每组数据			后,都测试firstCase的值，若其为true, 则表示当前处理的数据是第1组 数据，不输出空行，并将firstCase变量改为			false.之后如果还有数据，那么在数据输入后对firstCase变量进行测试，而firstCase变量此时已是false,在输出的叠			笸前额外输出一个空行， 达到了题面对输出格式的要求。
			②边界数据处理。根据上文,在缓存数组中完成字符阵列排版后，需要将这个阵列4个角的字符修改为空格，但这一			修改并不是一定需要的。当输入的n为1时，这一修改会变得多余，它会使输出仅变为一个空格，这与题面要求不			符。

​		因此，在进行这一修改之前，需要对n的数值进行判断，若其不为1则进行修改，否则跳过修改部分。
​		由此，不难看出，机试考题要求考生在作答时，不仅要能够把握算法，而且要细致地考虑边界数据会给程序造成什么		样的影响。只有充分考虑了所有情况，并且在题面明确将会出现的所有条件下，保证程序依旧能够正常地工作，才能		使程序真正符合题目要求。
​		本例介绍了另一种求解排版题的思路。
​		当输出图形具有的规律不能或很难直接应用到输出时，就应考虑采用该例所用的方法，即首先用一个缓存数组来保存将要输出的字符阵列,然后在该数组上完成排版。按照自己的需要或图形的规律完成排版后，依次输出图形，

##### 习题1 Repeater (北京大学复试上机题)

[题目大意]：给你一个仅包含一种字符和空格的模板，桢板品示如何创建无尽的图片，将字符
用作基本元素并将它们放在正确的位置以形成更大的模板，然后不断进行该操作。

```

```



##### 习题1 Hello World for U (浙江大学复试上机题)

[题目大意]：给定任意N≥5个字符的字符串，要求将该字符串组成U形，而且字符必须按照
给定字符串原来的顺序进行打印。

```

```

#### 2.2.2 日期问题

1.日期类运算的各种问题同样被频繁地选入机试考题中，但这类问题通常都有规律可循。
2.只要能够把握这类问题题面中的核心规律，求解这类问题就不会有太大的难度。

3.日期类题目的一-种常见求解方法是预处理，即在程序真正开始处理输入数据前，预处理出所有月份的天数并保存。
真正需要处理数据时，只需用O(1)的时间复杂度便可读出保存的数据，稍加处理后便能得到答案。
值得一提的是，预处理是以空间换时间的常见手段(保存预处理所得数据所需的内存来换取实时处理所需的时间消耗)。
日期类问题通常有一个需要特别注意的要点一闰年：
	每逢闰年，2月就会有29天,这对天数的计算势必产生重大影响。
	这里必须明确闰年的判断规则:当年数不能被100整除时，若其能被4整除(普通闰年)或能被400整除(世纪闰年)，
	则为闰年。用逻辑语言表示即(year%4==0&&year % 100 != 0) || (year % 400 == 0)，当这个逻辑表达式为true时，其为	闰年，否则不是闰年。从中还可看出，闰年并不严格按照每4年一次的规律出现，在某种情况下也可能出现两个相邻闰	年相隔8年的情况(如1896 年与1904 年)。因此，应严格按照上述表达式来判断某年是否是闰年，而不能采用某个闰年后	的第四年又是闰年的规则

##### 例题1(当前日期是今年的第几天)

①预处理每个月的天数，用二维数组提前保存平年和闰年的每月天数，这样在数据处理过程中就不必逐月地判断，有利于提高代码的效率，是1种空间换时间的常用技巧，而且也会使得代码更加有逻辑，减少出错的概率。
②为了判断某年是否是闰年，定义了一个函数(尽量用函数而不要用宏定义)，这个函数利用上文中提到的逻辑表达式来判断该年是否是闰年，根据这个表达式的逻辑值使表达式为1或0，并且根据逻辑值来选择保存每月天数的数组的不同行，取
得该月应有的天数，进而保证闰年时存在2月29日。

```java
/*
今年的第几天? ( 清华大学复试上机题)
    题目描述:输入年、月、日，计算该天是本年的第几天。
    输入:包括3个整数:年(1≤Y≤3000)、月(1≤M≤12)、日(1 ≤D≤31)。.
    输出:
    输入可能有多组测试数据，对于每组测试数据，
    输出一个整数，代表Input中的年、月、日对应本年的第几天。
 */
public class WhatDay {
    //数据预先保存在二维数组中
    int daytab[][] = {
            {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},//普通年
            {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}//闰年：2月=>29天
    };
    //闰年判断函数
    int isLeapYear(int year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
            return 1;
        else
            return 0;
    }
    public static void main(String[] args) {
        WhatDay wd = new WhatDay();
        Scanner input = new Scanner(System.in);
        int year = input.nextInt();//输入判断的年份
        int month = input.nextInt();//输入判断的月份，值为当前月
        int day = input.nextInt();//输入现在月的天数
        int number = 0;
        int index = wd.isLeapYear(year);
        for (int i = 0; i < month; i++) {//这里必须是"<"，
            number += wd.daytab[index][i];//累加当前月之前=>每月的天数
        }
        number += day; //再累加上当前月的天数
        System.out.println(+month+"月"+day+"号的天数为 "+number);
    }
}
```

例题2(今年的第几天是什么日期)
打印日期(华中科技大学复试上机题)=>上题的反向输出
    题目描述:
        给出年份m和一年中的第n天，算出第n天是几月几号。
    输入:
        输入包括两个整数: y (1≤y≤3000)和n (1≤nS 366)。
    输出:
        可能有多组测试数据，对于每组数据，
        按格式yyyy-mn-dd将输入中对应的日期打印出来。

```java
/**
 * 思路 判断年份是否为闰年，进入不同的数组=>for循环(最大12次)累加月份的天数,循环体内判断是否越过给出的天数
 * =>越过后说明循环体内的month的前一个月为当前月=>第n天减去当前月的累加日=>day
 * sout=> month、day
 */
 public class WhatDate {
    //数据预先保存在二维数组中
    static int daytab[][] = {
            {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},//普通年
            {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}//闰年：2月=>29天
    };
    //日期格式化
    public static String formatDate(int year, int month, int day) {
        return year + "-" + month + "-" + day;
    }
    //闰年判断函数
    static int isLeapYear(int year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
            return 1;
        else
            return 0;
    }
    public static void main(String[] args) {
        WhatDay2 wd2 = new WhatDay2();
        Scanner input = new Scanner(System.in);
        int year = input.nextInt();//输入判断的年份
        int daySum = input.nextInt();//输入当前年的第n天
        int number = 0;
        int lastNumber = 0;
        int day = 0;
        int month = 0;
        int index = isLeapYear(year);
        for (int i = 1; i <= 12; i++) {//这里必须是"<"，
            number += daytab[index][i];//累加每月的天数
            lastNumber =number - daytab[index][i];//上个月的累加天数=当前月最大天数-当前月的天数
            if(number>daySum){
                day = daySum-lastNumber;//当前月的天数
                month = i;//当前月
                break;//退出循环
            }
        }
        String date = formatDate(year,month,day);
        System.out.println(date);
    }
}
```

```java
这道题是上道题的逆问题。上道题是知道年、月日而求天数:
	本题是知道天数和年，反过来求月和日。因此，上题代码的主体可以不变，只需对求天数部分的代码稍做修改:
	从逐月不断累加天数，变成天数不断减少，直到求出月份，剩下的天数便是日期，从而完成解答。
	然而，本题的输出要求年必须是4位，月和日必须是2位，对于位数不足的数据，应该前置补零。例如，如果是985年2月1日,那	 么应该输出0985-02-01.如果考生不对输出做任何限制，那么就会输出格式985-2-1.这样的结果会被直接判错。要解决这个	问题，需要学会printf函数的输出格式，printf函数可以在”%”和字母之间插入数字表示最大场宽。下面给出常用的输出格式	样例:
		%2d表示输出场宽为2的整数，超过2位按实际数据输出，不够2位右对齐输出。
		%02d表示输出场宽为2的整数，超过2位按实际数据输出，不够2位前置补0。
		%5.2f表示输出场宽为5的浮点数，其中小数点后有2位，不够5位右对齐输出。
public class WhatDate2 {
    //数据预先保存在二维数组中
    int daytab[][] = {
            {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},//普通年
            {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}//闰年：2月=>29天
    };

    //闰年判断函数
    int isLeapYear(int year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
            return 1;
        else
            return 0;
    }

    //判断整数位数
    int judgeDigit(int year) {
        int count = 1;
        while (year / 10 > 1) {
            year = year / 10;
            count++;
        }
        return count;
    }

    public static void main(String[] args) {
        WhatDate2 wd = new WhatDate2();
        Scanner input = new Scanner(System.in);
        int year = input.nextInt();//输入判断的年份
        int number = input.nextInt();//输入判断的天数
        int month = 0;
        int day = 0;
        int index = wd.isLeapYear(year);
        while (number > wd.daytab[index][month]) { //从第一个月的最大天数开始减
            number -= wd.daytab[index][month]; //累减
            month++;
        }
        //为年份为4位数以下
        int count = wd.judgeDigit(year);
        if (count < 4) {
            String strYear = "0" + year;
            System.out.println("日期为：  " + strYear + "-" + month + "-" + day);
        }
        day = number; //最后累减完了的number < 月份中的最大日期 => 当前月的当前天数
        System.out.println("日期为：  " + year + "-" + month + "-" + day);
    }
}
```

