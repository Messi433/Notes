# Java欠缺知识点

## 一、JavaSE基础

### 1.基础知识篇笔记

- [x] 1.2.7：类型擦除

  （1）Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除

  （2）代码中定义`List<Object>`和`List<String>`等类型，在编译后都会变成`List`，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别

  （3）类型擦除的体现（都变成了原始类型且相等）：`list1.getClass() == list2.getClass()`

  （4）可通过反射添加其它类型元素

  （5）指定泛型与不指定泛型的，类型指定

  （6）类型擦除引起的问题及解决方法

- [ ] 1.2.8 ==和equals的区别

  > Java只有值传递，不管是 基本数据类型 or 引用数据类型，都是比较值，只不过**引用数据类型值是内存地址**	

  （1）==：比较两个对象的地址是否相等，两个对象是否同一个对象

  （2）==：基本数据类型比较值，引用数据类型比较内存地址

  （3）equals() : 判断两对象内存地址是否相等，但是不能比较基本数据类型

  （4）equals()覆盖与不覆盖的作用

  （5）String中的eq()的作用，串池

  

- [ ] 1.2.9 hashCode()与 equals()  

  （1）hashCode()   获取hashcode，作用是定义对象在hashtable的索引位置

  （2）为什么需要hashcode？例子：HashSet如何检查重复：`先检查hashcode？再判断eq()：非重复`

  （3）为什么要重写eq()时必须要重写hashcode()？

  可以类比（2），hashcode是第一步，第二步是eq()，hashcode相等，对象不一定等（hashcode相等，拉链法拉到同一个了）

  （4）**如何重写eq()、hashcode()，怎么写**？

- [ ] 1.3.1 基本数据类型的对应包装类型、占用空间大小，怎么算的
  （1）Integer(8+4+4)：8包装对象 + 4基本数据类型 + 4位对齐

  （2）boolean：逻辑上占一位

- [ ] 1.3.2 ⾃动装箱与拆箱

  ```java
  Integer i = new Integer(10); //Java SE5之前
  Integer i = 10;  //装箱
  int n = i;   //拆箱
  ```

  （1) 装箱和拆箱是如何实现的？（不会）

  （2）https://www.cnblogs.com/dolphin0520/p/3780005.html

  

- [ ] 1.3.3

- [ ] 1.4.2 为什么 Java 中只有值传递 

  

- [ ] 1.4.4 **深拷⻉ vs 浅拷⻉**

  浅拷贝：对基本数据类型进行值传递，对引用数据类型进行**引用传递般的拷贝**，此为浅拷贝。
  深拷贝：对基本数据类型进行值传递，对引用数据类型，**创建一个新的对象，并复制其内容，此为深拷贝**。

- [ ]   2.1.9

  #### 2.5

  

